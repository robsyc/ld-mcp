"""Table of Contents parsing for W3C specifications."""

import re
from typing import Optional

from bs4 import BeautifulSoup, Tag

from models import TOCItem


def parse_sections_as_toc(soup: BeautifulSoup, skip_acknowledgements: bool = True) -> list[TOCItem]:
    """
    Parse TOC from <section id="..."> elements (ReSpec format).

    ReSpec specs have structured section elements with IDs, but the headings
    inside don't have IDs (they're generated by JavaScript).
    """
    items = []

    for section in soup.find_all("section", id=True):
        section_id = section.get("id")

        # Skip standard boilerplate sections
        if section_id in ("abstract", "sotd", "conformance", "references", "index"):
            continue

        # Find heading inside section
        heading = section.find(["h2", "h3", "h4", "h5", "h6"])
        if not heading:
            continue

        title = heading.get_text(strip=True)
        if not title:
            continue

        if skip_acknowledgements and "acknowledgment" in title.lower():
            continue

        # Determine depth from heading level
        depth = int(heading.name[1]) - 1  # h2=1, h3=2, h4=3

        items.append(
            TOCItem(id=section_id, title=title, depth=depth, anchor=section_id, children=[])
        )

    return items


def parse_headings_as_toc(soup: BeautifulSoup, skip_acknowledgements: bool = True) -> list[TOCItem]:
    """
    Fallback TOC extraction by parsing heading elements with IDs directly.

    Used for older specs where headings have IDs but there's no TOC container.
    """
    items = []

    for heading in soup.find_all(["h2", "h3", "h4"]):
        heading_id = heading.get("id")
        if not heading_id:
            continue

        title = heading.get_text(strip=True)
        if not title:
            continue

        if skip_acknowledgements and (
            re.match(r"^[A-Z]\.", title) or "acknowledgment" in title.lower()
        ):
            continue

        depth = int(heading.name[1]) - 1  # h2=1, h3=2, h4=3

        items.append(
            TOCItem(id=heading_id, title=title, depth=depth, anchor=heading_id, children=[])
        )

    return items


def _parse_toc_paragraph(p_tag: Tag) -> list[TOCItem]:
    """Parse old-style TOC using <br/> separated links in <p> tags."""
    items = []
    for link in p_tag.find_all("a", href=True):
        href = link.get("href", "")
        if not href.startswith("#"):
            continue
        anchor = href.lstrip("#")
        title = link.get_text(strip=True)
        if not title:
            continue
        # Estimate depth from leading spaces/indentation in preceding text
        depth = 1
        prev = link.previous_sibling
        if prev and isinstance(prev, str):
            stripped = prev.lstrip()
            indent = len(prev) - len(stripped)
            depth = max(1, indent // 4 + 1)
        items.append(TOCItem(id=anchor, title=title, depth=depth, anchor=anchor, children=[]))
    return items


def _parse_toc_list(
    ol_or_ul: Tag, depth: int = 1, skip_acknowledgements: bool = True
) -> list[TOCItem]:
    """Recursively parse a TOC list (ol/ul)."""
    items = []
    for li in ol_or_ul.find_all("li", recursive=False):
        link = li.find("a", recursive=False) or li.find("a")
        if not link:
            continue

        href = link.get("href", "")
        anchor = href.lstrip("#") if href.startswith("#") else None
        title = link.get_text(strip=False)

        if skip_acknowledgements and (
            re.match(r"^[A-Z]\.", title) or "acknowledgments" in title.lower()
        ):
            continue

        section_id = anchor or re.sub(r"[^a-z0-9]+", "-", title.lower()).strip("-")

        item = TOCItem(id=section_id, title=title, depth=depth, anchor=anchor, children=[])

        # Look for nested list (children)
        nested = li.find(["ol", "ul"], recursive=False)
        if nested:
            item.children = _parse_toc_list(nested, depth + 1, skip_acknowledgements)

        items.append(item)

    return items


def parse_w3c_toc(soup: BeautifulSoup, skip_acknowledgements: bool = True) -> list[TOCItem]:
    """
    Parse Table of Contents from a W3C specification.

    Tries multiple strategies:
    1. TOC containers (nav#toc, div.toc, etc.)
    2. Section elements with IDs (ReSpec)
    3. Headings with IDs (older specs)
    """
    # Try to find TOC container
    toc_container = None

    # Try by id first
    for tag in ["nav", "div", "section", "table"]:
        toc_container = soup.find(tag, id="toc")
        if toc_container:
            break

    # Try by class
    if not toc_container:
        toc_container = soup.find("div", class_="toc")
    if not toc_container:
        toc_container = soup.find("nav", class_="toc")

    # Some older specs have a heading "Table of Contents" followed by a list
    if not toc_container:
        toc_heading = soup.find(["h2", "h3"], string=re.compile(r"Table of Contents", re.I))
        if toc_heading:
            next_list = toc_heading.find_next_sibling(["ol", "ul"])
            if next_list:
                toc_container = next_list.parent

    # Fallback: try section elements (ReSpec), then headings
    if not toc_container:
        items = parse_sections_as_toc(soup, skip_acknowledgements)
        if items:
            return items
        return parse_headings_as_toc(soup, skip_acknowledgements)

    # Parse TOC container
    main_list = toc_container.find(["ol", "ul"])
    if main_list:
        return _parse_toc_list(main_list, skip_acknowledgements=skip_acknowledgements)

    # Fallback: old-style <p class="toc"> with <br/> separated links
    toc_para = toc_container.find("p", class_="toc")
    if toc_para:
        return _parse_toc_paragraph(toc_para)

    return []


def flatten_toc(toc: list[TOCItem], max_depth: Optional[int] = None) -> list[dict]:
    """Flatten a nested TOC into a list of items with depth info."""
    result = []

    def collect(items: list[TOCItem], current_depth: int = 1):
        for item in items:
            if max_depth is None or current_depth <= max_depth:
                result.append({"id": item.id, "title": item.title, "depth": item.depth})
                if item.children:
                    collect(item.children, current_depth + 1)

    collect(toc)
    return result


def toc_to_markdown(toc: list[TOCItem], depth: int = 0, show_keys: bool = True) -> str:
    """Convert TOC to markdown format with optional section IDs."""
    out = ""
    for item in toc:
        out += "\t" * depth + item.title + (f" [{item.id}]" if show_keys else "") + "\n"
        if item.children:
            out += toc_to_markdown(item.children, depth + 1, show_keys)
    return out
